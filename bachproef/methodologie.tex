%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}%
\label{ch:methodologie}

%% TODO: In dit hoofstuk geef je een korte toelichting over hoe je te werk bent
%% gegaan. Verdeel je onderzoek in grote fasen, en licht in elke fase toe wat
%% de doelstelling was, welke deliverables daar uit gekomen zijn, en welke
%% onderzoeksmethoden je daarbij toegepast hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent.
%% 
%% Voorbeelden van zulke fasen zijn: literatuurstudie, opstellen van een
%% requirements-analyse, opstellen long-list (bij vergelijkende studie),
%% selectie van geschikte tools (bij vergelijkende studie, "short-list"),
%% opzetten testopstelling/PoC, uitvoeren testen en verzamelen
%% van resultaten, analyse van resultaten, ...
%%
%% !!!!! LET OP !!!!!
%%
%% Het is uitdrukkelijk NIET de bedoeling dat je het grootste deel van de corpus
%% van je bachelorproef in dit hoofstuk verwerkt! Dit hoofdstuk is eerder een
%% kort overzicht van je plan van aanpak.
%%
%% Maak voor elke fase (behalve het literatuuronderzoek) een NIEUW HOOFDSTUK aan
%% en geef het een gepaste titel.

Volgende hoofdstukken verlopen in sequentiële volgorde om dit onderzoek in de juiste richting te sturen.
De literatuurstudie geeft een basis om verdere vakterminologie en werking van technologieën te kunnen begrijpen.
\\
De setup van het huidige systeem wordt besproken om de requirements te kunnen begrijpen.
Het bekomen van een shortlist wordt toegelicht waarbij voor elke technologie de voor- en nadelen wordt beschreven.


\section{Phase 1: Literatuurstudie}
Voor dit onderzoek heb ik eerst de vaktermen opgelijst en onderverdeeld in groepen met behulp van een mindmap.
Vervolgens werd er gebruik gemaakt van het internet om wetenschappelijke artikelen op te zoeken en filterde ik de nodige informatie.
\\
Het doel van de literatuurstudie is om een basis van bestaande kennis te verkrijgen door de belangrijkste concepten toe te lichten die van toepassing zijn op dit onderzoek. 
Dit houd in, het begrijpen van warehousing, WCS (Warehouse Control Systems), PLC (Programmable Logic Controllers), en de communicatieprotocollen die tussen deze systemen gebruikt worden.
\\
Hierdoor krijg je een overzicht van relevante theorieën, definities, en eerdere studies die inzicht geven in de werking en de gebruikte technologieën.
Hier werd voornamelijk gebruik gemaakt van wetenschappelijke artikelen, boeken en technische documenten.
\\
De literatuurstudie vormt de basis van het onderzoek en is cruciaal voor het begrijpen van de huidige stand van zaken.
Hierdoor kan de kennis en requirements meegenomen worden doorheen de methodologie.


\section{Phase 2: Requirements analyse van huidige setup}
Dit hoofdstuk gaat dieper in op de huidige setup en werking tussen het WCS, messaging software en de PLC's.
Documenten van het bedrijf en interviews met vakexperts vormen de basis voor dit overzicht.
\\
Het doel is om na het lezen van dit hoofdstuk inzicht te krijgen in de requirements van het huidige systeem, 
zodat deze kunnen dienen als basis voor de keuze van een surrogaat van het huidige messaging systeem.
 
\subsection{PLC gebruik binnen TVH}
Er zijn 7 verschillende PLC's in TVH Waregem die instaan voor verschillende zones van de conveyor.
Deze werden aangeleverd door Vanderlanden in het jaar 2013 en worden beheerd door het automatisatie team.
De communicatie tussen een PLC en het WCS is gebaseerd op het TCP/IP protocol en is verbonden via het intern netwerk.
Er is een tussenlaag tussen de PLC en het netwerk, RFC1006 van het merk Siemens waarin configuratie kan worden gedaan door het automatisatie team.
Dit stelt de collega's in staat om bepaalde logica te implementeren of netwerk aanpassingen door te voeren.
De snelheid van communicatie is essentieel, daarom moet het netwerk snel genoeg zijn zodat berichten aan een snel tempo verstuurd kunnen worden.

De PLC's maken gebruik van een TCP/IP-socketverbinding en functioneren als client ten opzichte van het WCS, dat de rol van server vervult. 
Dit betekent dat de PLC de verbinding initieert en persisteert met de server die verantwoordelijk is voor de communicatie.
Een PLC is verantwoordelijk voor een specifieke zone van de conveyor en is opgebouwd uit drie kanalen die elk via een toegewezen poortnummer met de server communiceren. 
Meerdere kanalen zijn nodig om de communicatiesnelheid te bevorderen en omdat elk kanaal zijn eigen type informatie verwerkt.

\begin{table}[!h]
    \centering
    \begin{tabular}{lcr}
      \toprule
      \textbf{Kanaal} & \textbf{Beschrijving} & \textbf{Type}                \\
      \midrule
      1                & Route informatie over transportbak          & Snel           \\
      2                & Informatie van PLC                          & Niet kritisch  \\
      3                & Overige informatie over transportbak        & Snel           \\
      \bottomrule
    \end{tabular}
    \caption[Channel assignment]{\label{tab:channel-assignment}Beschrijving van kanalen}
  \end{table}

\subsubsection{PLC berichten}
Berichten bestaan uit een frame opgedeeld in velden en hebben een specifieke lengte.
De inhoud van een bericht is gebaseerd op het hexadecimale stelsel en wordt in detail toegelicht in de onderstaande tabel.
Bepaalde controles worden uitgevoerd om de validiteit van een bericht af te toetsen. 

\begin{table}[h!]
  \centering 
  \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Veld} & \textbf{Inhoud} & \textbf{Data type} & \textbf{Lengte} \\
    % \hline
    % Dummy & Enkel PLC naar WCS
    \hline 
    Header & <STX> & Binair & 1 byte \\
    \hline 
    Lengte in bytes & 001D(HEX) & Binair & 2 bytes \\
    \hline 
    Seq. nummer &  [0-9] & ASCII & 1 byte  \\
    \hline 
    Inhoud & <...> & Binair & 27 bytes \\
    \hline 
    Terminator & <ETX> & Binair & 1 byte \\
    \hline
  \end{tabular}
  \caption[Message content]{\label{tab:message-content}Inhoud bericht}
\end{table}

Voorbeeld van een bericht dat van PLC naar WCS wordt verstuurd: 
\begin{listing}[h!]
  \begin{minted}{python}
    02 00 1d 20 30 36 20 20 00 00 20 20 30 37 20 20 30 20 20 20 20 20 20 20 20 20 20 20 20 20 20 03
  \end{minted}
  \caption[Voorbeeld PLC bericht]{Voorbeeld van een PLC bericht}
\end{listing}

Een bericht kan dus maximaal 32 bytes groot zijn en wordt in rekening gehouden voor de testen in latere fase.

\subsection{WCS communicatie} 
Op het ERP-systeem van TVH draaien acht verschillende batches die verantwoordelijk zijn voor de aansturing van de PLC. 
Elke batch-instantie communiceert met specifieke PLC-kanalen en bevat daarvoor specifieke logica.
Deze batches zijn verbonden via een specifieke poort met een \textbf{Progress JMS Adapter} op de communicatie server.
Hiermee kunnen de batches de berichten consumeren en versturen van de SonicMQ server.

\subsection{Progress OpenEdge JMS Adapter}
De adapter stelt OpenEdge-applicaties in staat om berichten te verzenden en te ontvangen van JMS (Java Messaging System)
message brokers zoals Apache ActiveMQ, IBM MQ, en TIBCO EMS. 
Dit betekent dat OpenEdge-applicaties kunnen integreren met andere systemen die JMS ondersteunen, 
zonder dat er directe afhankelijkheden nodig zijn.
Hierdoor zijn we gelimiteerd in de keuze van message brokers.
\\
\\
Omdat JMS asynchrone communicatie ondersteunt, kunnen OpenEdge-applicaties berichten verzenden zonder te wachten op een onmiddellijke respons.
Dit is nuttig voor werkprocessen die niet direct afhangen van real-time gegevens, zoals orderverwerking, 
melding van gebeurtenissen, en batchverwerkingen.
\\\\
Er is ondersteuning van Publish/Subscribe en Point-to-Point Modellen.
Bij een point-to-point communiceert één afzender met één ontvanger, bijvoorbeeld een opdracht naar een specifieke applicatie.
\\\\
Bij het publish/subscribe model kunnen meerdere ontvangers zich abonneren op bepaalde berichten (topics) die door een applicatie gepubliceerd worden.

Door JMS te gebruiken met message brokers die schaling en betrouwbaarheid ondersteunen, kan de OpenEdge-omgeving hoge verwerkingsvolumes en failover-functionaliteit realiseren. 
Dit is belangrijk voor bedrijfsomgevingen waar de continuïteit en betrouwbaarheid van berichtenstromen essentieel zijn.

\subsubsection{Integratie met Verschillende Enterprise Systemen}
Met de JMS Adapter kunnen OpenEdge-applicaties communiceren met andere zakelijke systemen zoals ERP's, CRM’s en databronnen, wat nuttig is in bedrijfsprocessen waarbij gegevens moeten worden gedeeld tussen verschillende systemen.

\subsubsection{Configuratie en Beheer}
De Progress OpenEdge JMS Adapter biedt configuratiemogelijkheden waarmee beheerders de communicatie kunnen aanpassen aan de vereisten van hun omgeving, 
zoals het instellen van queue-namen, topics, verbindingsparameters, en het beheren van uitzonderingen.
 
\subsection{WCS berichten} 
Berichten komen binnen van de PLC via de communicatie server. Ieder bericht wordt getransformeerd naar variabelen die dan verder gebruikt worden in de code.
Deze berichten bevatten informatie over transportbakken en zijn nodig om deze te kunnen traceren via de ERP.
Specifieke logica is nodig om bakken tot hun bestemming te krijgen, of om fout afhandeling te voorzien.
Volgende voorbeelden doen zich voor:
\begin{enumerate}
  \item Routeren naar een hospitaal punt door: 
  \begin{enumerate}
    \item Gewichtsfout
    \item Hoogtefout
    \item Onbekende bestemming
  \end{enumerate}
  \item Bestemming wordt gevraagd door de PLC
  \item Bestemming wordt doorgegeven aan de PLC 
  \item Specifieke logica moet uitgevoerd worden bij het passeren van een bepaald punt
  \item \dots
\end{enumerate}

\subsection{Middleware tussen PLC en WCS}
De PLC kan alleen maar een TCP/IP socket verbinding initiëren met een server.
Omdat SonicMQ als middleware hierdoor geen verbinding kan maken zijn er listeners gemaakt in Java door TVH.
Deze listeners fungeren als server en zijn specifiek opgesteld om een TCP/IP socket verbinding mogelijk te maken per PLC kanaal.
De Java listeners sturen de PLC-berichten vervolgens door naar SonicMQ of ontvangen berichten van SonicMQ, 
die ze via een socket naar de PLC doorsturen.
Aan de kant van het WCS zijn er meer mogelijkheden om verbinding te kunnen maken met een server.


\subsection{Samenvatting requirements messaging systeem}
De belangrijkste requirements voor de huidige setup zijn als volgt:

\subsubsection{Integratie met het WCS systeem}
Het messaging systeem moet kunnen integreren met het huidige WCS-systeem dat Progress 4GL gebruikt. 
Deze technologie maakt gebruik van een Progress OpenEdge JMS Adapter om de connectie te maken met een messaging broker.
Deze integratie is noodzakelijk voor het efficiënt uitwisselen van informatie over transportbakken, inclusief routeringsinformatie, 
foutmeldingen, en statusupdates.

\subsubsection{Performantie}
Om de real-time eisen van het WCS en de PLC’s te ondersteunen, moet het messaging systeem lage latentie bieden. 
Dit betekent dat berichten zonder merkbare vertraging moeten worden verstuurd en ontvangen, 
zodat de snelheid van de conveyor niet wordt beperkt door de communicatiesnelheid.

\subsubsection{Betrouwbare Berichtenoverdracht}
Het systeem moet in staat zijn berichten consistent en zonder verlies over te brengen. 
Dit is essentieel om de traceerbaarheid van transportbakken te garanderen en fouten in de logistieke processen te voorkomen.

\subsubsection{Support en Community}
Het is belangrijk dat de gekozen message broker support biedt en dat er een grote community aanwezig is 
waarbij je terecht kunt voor advies, probleemoplossing en best practices.

\section{Phase 3: Long List}

\begin{table}[h!]
  \centering
  \begin{tabular}{|l|c|c|c|c|c|}
  \hline
  Message Broker & JVM Ondersteuning & Unix & Populaire Protocollen & Kostenmodel & Cloud toepasbaar \\
  \hline
  Apache Kafka & Ja & Ja & Kafka, MQTT, REST & Open-source (mogelijke kosten voor ondersteuning) & Ja (geschikt) \\
  \hline
  RabbitMQ & Ja & Ja & AMQP, MQTT, STOMP & Open-source (mogelijke kosten voor ondersteuning) & Ja (geschikt) \\
  \hline
  ActiveMQ & Ja & Ja & AMQP, MQTT, STOMP, OpenWire & Open-source (mogelijke kosten voor ondersteuning) & Ja (geschikt) \\
  \hline
  MQTT.js & Ja & Ja & MQTT & Open-source & Ja (geschikt) \\
  \hline
  IBM MQ & Ja & Ja & MQ, MQTT, JMS & Commercieel (abonnement) & Ja (geschikt) \\
  \hline
  Redis & Ja (optioneel) & Ja & Pub/Sub & Open-source (mogelijke kosten voor ondersteuning) & Ja (geschikt) \\
  \hline
  NSQ & Ja & Ja & NSQ Protocol & Open-source & Ja (geschikt) \\
  \hline
  Apache Pulsar & Ja & Ja & Pulsar Protocol, MQTT, Kafka & Open-source (mogelijke kosten voor ondersteuning) & Ja (native) \\
  \hline
  NATS & Ja & Ja & NATS Protocol & Open-source (mogelijke kosten voor ondersteuning) & Ja (native) \\
  \hline
  ZeroMQ & Ja & Ja & ØMQ & Open-source & Ja (geschikt) \\
  \hline
  Amazon SQS & Nee & Nee (cloud-service) & AWS-eigen protocol & Pay-per-use & Ja (native) \\
  \hline
  Google Cloud Pub/Sub & Nee & Nee (cloud-service) & Cloud Pub/Sub Protocol & Pay-per-use & Ja (native) \\
  \hline
  Azure Service Bus & Nee & Nee (cloud-service) & AMQP, MQTT, HTTP & Pay-per-use & Ja (native) \\
  \hline
  \end{tabular}
  \caption{\label{tab:message_brokers}Longlist message brokers}
  \end{table}

\section{Phase 4: ShortList}

\section{Phase 5: Testen}
Opzoeken van test methodes 
% https://www.researchgate.net/publication/342312542_Classification_and_evaluation_of_IoT_brokers_A_methodology

Testen en monitoring opzetten per gekozen technologie

Opzet simulator PLC:
\begin{listing}[h!]
    \begin{minted}{python}
      import socket
import configparser
import logging
import os
import random
import threading
import queue
import time


def setup_logging(log_file_path):
    """Set up logging configuration."""
    os.makedirs(os.path.dirname(log_file_path), exist_ok=True)
    logging.basicConfig(
        filename=log_file_path,
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
    )


def generate_random_message():
    """Generates a random hexadecimal message."""
    message_template = [
        "02", "00", "1d", "20",
        f"{random.randint(0, 255):02x}", f"{random.randint(0, 255):02x}", "20", "20", "00", "00", "20", "20",
        f"{random.randint(0, 255):02x}", f"{random.randint(0, 255):02x}", "20", "20",
        f"{random.randint(0, 255):02x}", "20", "20", "20", "20", "20", "20", "20", "20", "20",
        "20", "20", "20", "20", "20", "03"
    ]
    return " ".join(message_template)


def send_messages(socket_conn, port, message_queue, stop_event):
    """Send messages from the queue to the socket."""
    while not stop_event.is_set():
        try:
            message = message_queue.get(timeout=1)  # Wait for a message from the queue
            socket_conn.send(bytes.fromhex(message.replace(" ", "")))
            logging.info(f"Sent to {port}: {message}")
            print(f"Sent to {port}: {message}")
            time.sleep(0.1)  # Simulate delay
        except queue.Empty:
            continue   


def receive_messages(socket_conn, port, buffer_size, stop_event):
    """Receive messages from the socket."""
    while not stop_event.is_set():
        try:
            data = socket_conn.recv(buffer_size)
            if data:
                message = data.hex()
                logging.info(f"Received from {port}: {message}")
                print(f"Received from {port}: {message}")
        except socket.error as e:
            logging.error(f"Error receiving from {port}: {e}")
            break


def handle_connection(host, port, buffer_size, message_queue, stop_event):
    """Handle socket connection, send and receive messages."""
    while not stop_event.is_set():
        try:
            # Create socket and connect to the server
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as socket_conn:
                socket_conn.connect((host, port))
                socket_conn.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)  # Disable Nagle's algorithm
                logging.info(f"Connected to {host}:{port}")
                print(f"Connected to {host}:{port}")
 
                send_thread = threading.Thread(target=send_messages, args=(socket_conn, port, message_queue, stop_event))
                receive_thread = threading.Thread(target=receive_messages, args=(socket_conn, port, buffer_size, stop_event))
 
                send_thread.start()
                receive_thread.start() 
                send_thread.join()
                receive_thread.join()

        except (ConnectionRefusedError, socket.timeout) as e:
            logging.error(f"Could not connect to {host}:{port} - {e}. Retrying in 5 seconds...")
            print(f"Retrying connection to {host}:{port} in 5 seconds...")
            time.sleep(5)


def generate_and_enqueue_messages(message_queue, stop_event):
    """Generate and enqueue random messages."""
    while not stop_event.is_set():
        message = generate_random_message()
        message_queue.put(message)
        logging.info(f"Enqueued message: {message}")
        print(f"Enqueued message: {message}")
        time.sleep(0.5) 


def main(): 

    config = configparser.ConfigParser()
    config.read("plc-config.ini")
 
    log_file_path = config["LOGGING"]["LOG_FILE"]
    setup_logging(log_file_path)
 
    host = config["SOCKET"]["HOST"]
    ports = [int(port.strip()) for port in config["SOCKET"]["PORTS"].split(",")]
    buffer_size = int(config["SOCKET"]["BUFFER_SIZE"])

    logging.info(f"Starting client for host {host} with ports {ports}")
 
    message_queue = queue.Queue()
    stop_event = threading.Event()

    try: 
        message_thread = threading.Thread(target=generate_and_enqueue_messages, args=(message_queue, stop_event))
        message_thread.start()

        connection_threads = []
        for port in ports:
            connection_thread = threading.Thread(target=handle_connection, args=(host, port, buffer_size, message_queue, stop_event))
            connection_threads.append(connection_thread)
            connection_thread.start()

        message_thread.join()
        for connection_thread in connection_threads:
            connection_thread.join()

    except KeyboardInterrupt:
        logging.info("Shutting down client...")
        stop_event.set()  # Signal all threads to stop

    finally:
        logging.info("Client stopped.")


if __name__ == "__main__":
    main()

    \end{minted}
    \caption[Python code PLC sim]{Code voor het simuleren van PLC verbinding}
\end{listing}

\section{Phase 6: Resultaten}

Evalueren
